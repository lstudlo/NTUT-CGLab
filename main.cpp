#include <GL/freeglut.h>
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm> // For std::min, std::max
#include <string>    // For std::string, std::to_string

// --- Configuration ---
const int NUM_ENDPOINTS = 3; // Changed to 3 for triangle
int gridDimension = 10;      // Grid range for endpoint selection (-10 to 10)
int cellSize = 15;           // Pixel size of each grid cell (affects visual size)
int windowWidth = 800;       // Initial window width
int windowHeight = 800;      // Initial window height
const unsigned int ANIMATION_DELAY = 10; // Milliseconds between animation steps

// --- Data Structures ---
struct Cell {
    int x, y;        // Grid coordinates
    bool isE;        // Pixel from E move in Midpoint?
    bool isNE;       // Pixel from NE move in Midpoint?
};

struct Line {
    Cell start, end;
    std::vector<Cell> pixels; // Pixels generated by Midpoint Algorithm
};

// --- Global State ---
Cell endpoints[NUM_ENDPOINTS];     // Stores the 3 triangle vertices
int currentEndpoint = 0;          // Index for selecting endpoints (0, 1, 2)
std::vector<Line> lines;          // Stores the 3 triangle edge lines
std::vector<Cell> triangleFillPixels; // Stores pixels inside the triangle
bool endpointsSelected = false;   // Flag indicating if all 3 endpoints are selected

// --- Animation State ---
bool isAnimatingFill = false;
int currentFillX, currentFillY;
int minFillX, maxFillX, minFillY, maxFillY; // Bounding box for current animation
Cell animV1, animV2, animV3; // Vertices for the triangle being animated
float animOrientationSign;   // Orientation sign for the triangle being animated


// --- Function Prototypes ---
void display();
void reshape(int w, int h);
void mouse(int button, int state, int x, int y);
void keyboard(unsigned char key, int x, int y);
void createMenu();
void menuCallback(int option);
void drawFaintGrid();
void drawCell(int x, int y, bool isE, bool isNE);
void drawFilledCell(int x, int y, float r, float g, float b);
void convertScreenToGrid(int screenX, int screenY, int& gridX, int& gridY);
void drawLines();
void drawMidpointLine(Line& line);
// void fillTriangle(const Cell& v1, const Cell& v2, const Cell& v3); // Will be replaced by animation logic
void startFillAnimation(const Cell& v1, const Cell& v2, const Cell& v3);
void animateFillStep(int value);
void clearAll();
float cross_product_sign(const Cell& p1, const Cell& p2, const Cell& p3);

// Helper function for triangle filling (half-plane check)
float cross_product_sign(const Cell& p1, const Cell& p2, const Cell& p3) {
    long long val = 1LL * (p2.x - p1.x) * (p3.y - p1.y) - 1LL * (p2.y - p1.y) * (p3.x - p1.x);
     if (val == 0) return 0.0f;
     return (val > 0) ? 1.0f : -1.0f;
}

// --- Main Function ---
int main(int argc, char** argv) {
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
    glutInitWindowSize(windowWidth, windowHeight);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("Animated Triangle Fill (Midpoint Outline)");

    glutDisplayFunc(display);
    glutReshapeFunc(reshape);
    glutMouseFunc(mouse);
    glutKeyboardFunc(keyboard);

    createMenu();

    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);
    glutMainLoop();
    return 0;
}

// --- Display Callback ---
void display() {
    glClear(GL_COLOR_BUFFER_BIT);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    gluOrtho2D(0, windowWidth, 0, windowHeight);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    drawFaintGrid();

    if (endpointsSelected || isAnimatingFill) { // Draw fill if fully selected OR if animating
        for (const auto& cell : triangleFillPixels) {
            drawFilledCell(cell.x, cell.y, 0.7f, 0.7f, 0.7f); // Light gray
        }
        drawLines(); // Outline
    }


    for (int i = 0; i < NUM_ENDPOINTS; ++i) {
        if (currentEndpoint > i || endpointsSelected) {
            drawFilledCell(endpoints[i].x, endpoints[i].y, 1.0f, 0.0f, 0.0f); // Red
            glColor3f(1.0f, 1.0f, 1.0f);
            int centerX = windowWidth / 2;
            int centerY = windowHeight / 2;
            int cellPixelX = centerX + endpoints[i].x * cellSize - cellSize / 2;
            int cellPixelY = centerY + endpoints[i].y * cellSize - cellSize / 2;
            glRasterPos2i(cellPixelX + cellSize / 4, cellPixelY + cellSize / 4);
            std::string label = "v" + std::to_string(i + 1);
            for (char c : label) {
                glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12, c);
            }
        }
    }
    glutSwapBuffers();
}

// --- Reshape Callback ---
void reshape(int w, int h) {
    windowWidth = w;
    windowHeight = h;
    glViewport(0, 0, w, h);
}

// --- Mouse Callback ---
void mouse(int button, int state, int x, int y) {
    if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN) {
        if (isAnimatingFill) {
            std::cout << "Animation in progress. Please wait or press 'C' to clear." << std::endl;
            return;
        }

        int gridX, gridY;
        convertScreenToGrid(x, windowHeight - 1 - y, gridX, gridY);

        if (gridX >= -gridDimension && gridX <= gridDimension &&
            gridY >= -gridDimension && gridY <= gridDimension) {

            if (currentEndpoint < NUM_ENDPOINTS) {
                endpoints[currentEndpoint].x = gridX;
                endpoints[currentEndpoint].y = gridY;
                endpoints[currentEndpoint].isE = false;
                endpoints[currentEndpoint].isNE = false;

                std::cout << "Endpoint v" << (currentEndpoint + 1) << " selected at: ("
                          << gridX << ", " << gridY << ")" << std::endl;
                currentEndpoint++;

                if (currentEndpoint == NUM_ENDPOINTS) {
                    endpointsSelected = true; // Mark as selected for outline drawing
                    lines.clear();
                    triangleFillPixels.clear(); // Clear previous fill

                    lines.resize(NUM_ENDPOINTS);
                    for(int i=0; i < NUM_ENDPOINTS; ++i) {
                        lines[i].start = endpoints[i];
                        lines[i].end = endpoints[(i + 1) % NUM_ENDPOINTS];
                        drawMidpointLine(lines[i]); // Calculate outline immediately
                    }
                    // Start animation for filling
                    startFillAnimation(endpoints[0], endpoints[1], endpoints[2]);
                    std::cout << "Triangle outline defined. Starting fill animation..." << std::endl;
                    std::cout << "Press 'C' to clear and select new points." << std::endl;
                }
            } else {
                 std::cout << "All 3 endpoints already selected. Press 'C' to clear." << std::endl;
            }
            glutPostRedisplay();
        } else {
             std::cout << "Clicked outside grid bounds (" << -gridDimension << " to " << gridDimension << ")." << std::endl;
        }
    }
}

// --- Keyboard Callback ---
void keyboard(unsigned char key, int x, int y) {
    switch (key) {
        case 'c':
        case 'C':
        case 'r':
        case 'R':
            clearAll();
            std::cout << "Cleared all points, fill, and stopped animation. Select 3 new endpoints." << std::endl;
            break;
        case 27: // Escape key
             exit(0);
            break;
    }
    glutPostRedisplay();
}

// --- Clear All Helper ---
void clearAll() {
    currentEndpoint = 0;
    endpointsSelected = false;
    lines.clear();
    triangleFillPixels.clear();

    // Stop and reset animation
    isAnimatingFill = false;
    // No need to explicitly call glutTimerFunc to cancel,
    // the check 'if(isAnimatingFill)' in animateFillStep will stop it.
    std::cout << "Animation stopped and cleared." << std::endl;
}

// --- Menu Creation ---
void createMenu() {
    int menu = glutCreateMenu(menuCallback);
    glutAddMenuEntry("Grid Range: 10x10 (-10 to 10)", 10);
    glutAddMenuEntry("Grid Range: 15x15 (-15 to 15)", 15);
    glutAddMenuEntry("Grid Range: 20x20 (-20 to 20)", 20);
    glutAttachMenu(GLUT_RIGHT_BUTTON);
}

// --- Menu Callback ---
void menuCallback(int option) {
    if (gridDimension != option) {
        gridDimension = option;
        std::cout << "Grid selection range set to: " << gridDimension << "x" << gridDimension
                  << " (" << -gridDimension << " to " << gridDimension << ")" << std::endl;
        clearAll();
        glutPostRedisplay();
    }
}

// --- Faint Grid Drawing ---
void drawFaintGrid() {
    int centerX = windowWidth / 2;
    int centerY = windowHeight / 2;
    int minPixelX = centerX - (gridDimension * cellSize) - (cellSize / 2);
    int maxPixelX = centerX + (gridDimension * cellSize) + (cellSize / 2);
    int minPixelY = centerY - (gridDimension * cellSize) - (cellSize / 2);
    int maxPixelY = centerY + (gridDimension * cellSize) + (cellSize / 2);

    glColor3f(0.15f, 0.15f, 0.15f);
    for (int i = -gridDimension; i <= gridDimension + 1; i++) {
        int x = centerX + i * cellSize - cellSize / 2;
        glBegin(GL_LINES);
        glVertex2i(x, minPixelY);
        glVertex2i(x, maxPixelY);
        glEnd();
    }
    for (int i = -gridDimension; i <= gridDimension + 1; i++) {
        int y = centerY + i * cellSize - cellSize / 2;
        glBegin(GL_LINES);
        glVertex2i(minPixelX, y);
        glVertex2i(maxPixelX, y);
        glEnd();
    }
    int originCellX = centerX - cellSize / 2;
    int originCellY = centerY - cellSize / 2;
    glColor3f(0.3f, 0.3f, 0.3f);
    glBegin(GL_LINES);
    glVertex2i(originCellX, originCellY + cellSize / 2);
    glVertex2i(originCellX + cellSize, originCellY + cellSize / 2);
    glVertex2i(originCellX + cellSize / 2, originCellY);
    glVertex2i(originCellX + cellSize / 2, originCellY + cellSize);
    glEnd();
}

// --- Simple Filled Cell Drawing ---
void drawFilledCell(int x, int y, float r, float g, float b) {
    int centerX = windowWidth / 2;
    int centerY = windowHeight / 2;
    int cellX = centerX + x * cellSize - cellSize / 2;
    int cellY = centerY + y * cellSize - cellSize / 2;

    glColor3f(r, g, b);
    glBegin(GL_QUADS);
    glVertex2i(cellX, cellY);
    glVertex2i(cellX + cellSize, cellY);
    glVertex2i(cellX + cellSize, cellY + cellSize);
    glVertex2i(cellX, cellY + cellSize);
    glEnd();
}

// --- Outline Cell Drawing ---
void drawCell(int x, int y, bool isE, bool isNE) {
    float r, g, b;
    if (isE) { r = 0.0f; g = 1.0f; b = 0.0f; } // Green
    else if (isNE) { r = 0.0f; g = 0.0f; b = 1.0f; } // Blue
    else { r = 1.0f; g = 1.0f; b = 1.0f; } // White
    drawFilledCell(x, y, r, g, b);
}

// --- Coordinate Conversion ---
void convertScreenToGrid(int screenX, int screenY, int& gridX, int& gridY) {
    int centerX = windowWidth / 2;
    int centerY = windowHeight / 2;
    float pixelDx = (float)(screenX - centerX);
    float pixelDy = (float)(screenY - centerY);
    gridX = static_cast<int>(std::floor(pixelDx / cellSize + 0.5f));
    gridY = static_cast<int>(std::floor(pixelDy / cellSize + 0.5f));
}

// --- Draw Lines --- (Outline)
void drawLines() {
    for (const auto& line : lines) {
        if (!line.pixels.empty()) {
            for (const auto& pixel : line.pixels) {
                 drawCell(pixel.x, pixel.y, pixel.isE, pixel.isNE);
            }
        }
    }
}

// --- Midpoint Line Algorithm ---
void drawMidpointLine(Line& currentLine) {
    currentLine.pixels.clear();
    int x0 = currentLine.start.x;
    int y0 = currentLine.start.y;
    int x1 = currentLine.end.x;
    int y1 = currentLine.end.y;

    bool steep = abs(y1 - y0) > abs(x1 - x0);
    bool swapXY = steep;

    if (steep) { std::swap(x0, y0); std::swap(x1, y1); }
    if (x0 > x1) { std::swap(x0, x1); std::swap(y0, y1); }

    int dx = x1 - x0;
    int dy = abs(y1 - y0);
    int signY = (y0 < y1) ? 1 : -1;
    int d = 2 * dy - dx;
    int delE = 2 * dy;
    int delNE = 2 * (dy - dx);
    int x = x0;
    int y = y0;

    auto addPixel = [&](int plot_x, int plot_y, bool isE, bool isNE) {
        int original_x = swapXY ? plot_y : plot_x;
        int original_y = swapXY ? plot_x : plot_y;
        currentLine.pixels.push_back({original_x, original_y, isE, isNE});
    };

    addPixel(x, y, false, false);
    while (x < x1) {
        bool movedE = false; bool movedNE = false;
        if (d <= 0) { d += delE; x++; movedE = true; }
        else { d += delNE; x++; y += signY; movedNE = true; }
        addPixel(x, y, movedE, movedNE);
    }
}

// --- Triangle Fill Animation ---
void startFillAnimation(const Cell& v1, const Cell& v2, const Cell& v3) {
    if (isAnimatingFill) return; // Don't start a new one if one is running

    triangleFillPixels.clear(); // Clear any previous fill pixels

    animV1 = v1; animV2 = v2; animV3 = v3;

    minFillX = std::min({v1.x, v2.x, v3.x});
    maxFillX = std::max({v1.x, v2.x, v3.x});
    minFillY = std::min({v1.y, v2.y, v3.y});
    maxFillY = std::max({v1.y, v2.y, v3.y});

    minFillX = std::max(minFillX, -gridDimension);
    maxFillX = std::min(maxFillX, gridDimension);
    minFillY = std::max(minFillY, -gridDimension);
    maxFillY = std::min(maxFillY, gridDimension);

    animOrientationSign = cross_product_sign(v1, v2, v3);

    if (animOrientationSign == 0.0f) {
        std::cout << "Vertices are collinear, no animation needed." << std::endl;
        endpointsSelected = true; // Still mark as fully selected for outline
        isAnimatingFill = false;
        glutPostRedisplay();
        return;
    }

    // Start scanning from top-left of bounding box
    // "Top" means higher Y in grid coordinates.
    currentFillY = maxFillY;
    currentFillX = minFillX;
    isAnimatingFill = true;

    std::cout << "Starting animation: Y from " << maxFillY << " down to " << minFillY
              << ", X from " << minFillX << " to " << maxFillX << std::endl;

    glutTimerFunc(ANIMATION_DELAY, animateFillStep, 0); // Start the animation loop
}

void animateFillStep(int value) {
    if (!isAnimatingFill) { // Animation might have been cancelled
        endpointsSelected = true; // Ensure it's marked as done for any final draw states
        glutPostRedisplay();
        return;
    }

    // Process one cell
    Cell p = {currentFillX, currentFillY, false, false};
    float d12 = cross_product_sign(animV1, animV2, p);
    float d23 = cross_product_sign(animV2, animV3, p);
    float d31 = cross_product_sign(animV3, animV1, p);

    bool inside = false;
    if (animOrientationSign > 0) { // CCW
        if (d12 >= 0 && d23 >= 0 && d31 >= 0) inside = true;
    } else { // CW
        if (d12 <= 0 && d23 <= 0 && d31 <= 0) inside = true;
    }

    if (inside) {
        triangleFillPixels.push_back(p);
    }

    // Move to next cell in "top to bottom, left to right" order
    currentFillX++;
    if (currentFillX > maxFillX) {
        currentFillX = minFillX; // Reset X
        currentFillY--;          // Move to next row down
    }

    glutPostRedisplay(); // Redraw the scene

    // Check if animation is complete
    if (currentFillY < minFillY) {
        isAnimatingFill = false;
        endpointsSelected = true; // Final state: fully selected
        std::cout << "Fill animation complete. Added " << triangleFillPixels.size() << " pixels." << std::endl;
    } else {
        glutTimerFunc(ANIMATION_DELAY, animateFillStep, 0); // Continue animation
    }
}