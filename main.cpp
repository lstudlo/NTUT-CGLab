#include <GL/freeglut.h>
#include <iostream>
#include <vector>
#include <cmath>
#include <algorithm> // For std::min, std::max

// --- Configuration ---
const int NUM_ENDPOINTS = 3; // Changed to 3 for triangle
int gridDimension = 10;      // Grid range for endpoint selection (-10 to 10)
int cellSize = 15;           // Pixel size of each grid cell (affects visual size)
int windowWidth = 800;       // Initial window width
int windowHeight = 800;      // Initial window height

// --- Data Structures ---
struct Cell {
    int x, y;        // Grid coordinates
    bool isE;        // Pixel from E move in Midpoint?
    bool isNE;       // Pixel from NE move in Midpoint?
};

struct Line {
    Cell start, end;
    std::vector<Cell> pixels; // Pixels generated by Midpoint Algorithm
};

// --- Global State ---
Cell endpoints[NUM_ENDPOINTS];     // Stores the 3 triangle vertices
int currentEndpoint = 0;          // Index for selecting endpoints (0, 1, 2)
std::vector<Line> lines;          // Stores the 3 triangle edge lines
std::vector<Cell> triangleFillPixels; // Stores pixels inside the triangle
bool endpointsSelected = false;   // Flag indicating if all 3 endpoints are selected

// --- Function Prototypes ---
void display();
void reshape(int w, int h);
void mouse(int button, int state, int x, int y);
void keyboard(unsigned char key, int x, int y);
void createMenu(); // Keep menu for grid dimension/range selection
void menuCallback(int option);
void drawFaintGrid(); // Draw a faint grid only for selection aid
void drawCell(int x, int y, bool isE, bool isNE); // Modified drawCell for outline
void drawFilledCell(int x, int y, float r, float g, float b); // Simple cell fill
void convertScreenToGrid(int screenX, int screenY, int& gridX, int& gridY);
void drawLines();                             // Draws triangle outline
void drawMidpointLine(Line& line);            // Midpoint algorithm implementation
void fillTriangle(const Cell& v1, const Cell& v2, const Cell& v3); // Triangle fill function
void clearAll();                              // Helper to clear selections

// Helper function for triangle filling (half-plane check)
// Returns positive if p3 is to the left of vector p1->p2, negative if to the right, 0 if collinear.
// Note: Y-axis is inverted in screen coordinates, but grid coordinates are Cartesian.
// This function uses Cartesian coordinates.
float cross_product_sign(const Cell& p1, const Cell& p2, const Cell& p3) {
    // (x2 - x1)*(y3 - y1) - (y2 - y1)*(x3 - x1)
    long long val = 1LL * (p2.x - p1.x) * (p3.y - p1.y) - 1LL * (p2.y - p1.y) * (p3.x - p1.x);
     if (val == 0) return 0.0f;
     return (val > 0) ? 1.0f : -1.0f;
}


// --- Main Function ---
int main(int argc, char** argv) {
    glutInit(&argc, argv);
    glutInitDisplayMode(GLUT_DOUBLE | GLUT_RGB);
    glutInitWindowSize(windowWidth, windowHeight);
    glutInitWindowPosition(100, 100);
    glutCreateWindow("Triangle Fill (Midpoint Outline)");

    glutDisplayFunc(display);
    glutReshapeFunc(reshape);
    glutMouseFunc(mouse);
    glutKeyboardFunc(keyboard);

    createMenu(); // Keep menu for grid dimension selection

    // Set background to black - Requirement 6
    glClearColor(0.0f, 0.0f, 0.0f, 1.0f);

    glutMainLoop();
    return 0;
}
// --- Display Callback ---
// Modified to always draw the faint grid
void display() {
    // Clear with black background - Requirement 6
    glClear(GL_COLOR_BUFFER_BIT);

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();
    // Set projection (origin bottom-left)
    gluOrtho2D(0, windowWidth, 0, windowHeight);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity();

    // --- MODIFICATION START ---
    // Always draw faint grid first as background aid
    drawFaintGrid();
    // --- MODIFICATION END ---


    // Draw triangle fill and outline only if endpoints are selected
    if (endpointsSelected) {
        // 1. Draw Fill (Light Gray) - Requirement 5
        // Drawn ON TOP of the faint grid now
        for (const auto& cell : triangleFillPixels) {
            drawFilledCell(cell.x, cell.y, 0.7f, 0.7f, 0.7f); // Light gray
        }

        // 2. Draw Outline (Green/Blue/White) - Requirement 3 & 4
        // Drawn ON TOP of the fill and faint grid
        drawLines(); // Calls drawCell for outline pixels
    }

    // 3. Draw Endpoints (Red) - Draw on top of everything else
    // Check if the endpoint has been selected (currentEndpoint > i)
    // or if all points are selected
    for (int i = 0; i < NUM_ENDPOINTS; ++i) {
        if (currentEndpoint > i || endpointsSelected) {
            // Red color for endpoint marker
            drawFilledCell(endpoints[i].x, endpoints[i].y, 1.0f, 0.0f, 0.0f);

            // Draw label (v1, v2, v3) - White text
            glColor3f(1.0f, 1.0f, 1.0f);
            int centerX = windowWidth / 2;
            int centerY = windowHeight / 2;
            // Calculate pixel coords for the label based on cell coords
             int cellPixelX = centerX + endpoints[i].x * cellSize - cellSize / 2;
             int cellPixelY = centerY + endpoints[i].y * cellSize - cellSize / 2; // Use '+' for Y due to gluOrtho2D

            // Position text slightly inside the cell
            glRasterPos2i(cellPixelX + cellSize / 4, cellPixelY + cellSize / 4);
            std::string label = "v" + std::to_string(i + 1);
            for (char c : label) {
                glutBitmapCharacter(GLUT_BITMAP_HELVETICA_12, c);
            }
        }
    }

    glutSwapBuffers(); // Display the completed frame
}
// --- Reshape Callback ---
void reshape(int w, int h) {
    windowWidth = w;
    windowHeight = h;
    glViewport(0, 0, w, h); // Use the full window
    // Projection matrix is reset in display()
}

// --- Mouse Callback ---
void mouse(int button, int state, int x, int y) {
    if (button == GLUT_LEFT_BUTTON && state == GLUT_DOWN) {
        int gridX, gridY;
        // Adjust y coordinate because OpenGL's origin is bottom-left,
        // but mouse events usually have origin top-left.
        convertScreenToGrid(x, windowHeight - 1 - y, gridX, gridY);

        // Check if click is within the selectable grid range
        if (gridX >= -gridDimension && gridX <= gridDimension &&
            gridY >= -gridDimension && gridY <= gridDimension) {

            if (currentEndpoint < NUM_ENDPOINTS) {
                endpoints[currentEndpoint].x = gridX;
                endpoints[currentEndpoint].y = gridY;
                endpoints[currentEndpoint].isE = false; // Initialize flags
                endpoints[currentEndpoint].isNE = false;

                std::cout << "Endpoint v" << (currentEndpoint + 1) << " selected at: ("
                          << gridX << ", " << gridY << ")" << std::endl;
                currentEndpoint++;

                if (currentEndpoint == NUM_ENDPOINTS) {
                    endpointsSelected = true;
                    lines.clear();
                    triangleFillPixels.clear();

                    // Create Line structures for triangle edges
                    lines.resize(NUM_ENDPOINTS); // Ensure vector has space
                    for(int i=0; i < NUM_ENDPOINTS; ++i) {
                        lines[i].start = endpoints[i];
                        lines[i].end = endpoints[(i + 1) % NUM_ENDPOINTS]; // Connect to next, wrap around
                        drawMidpointLine(lines[i]); // Calculate pixels for the outline
                    }

                    // Calculate fill pixels
                    fillTriangle(endpoints[0], endpoints[1], endpoints[2]);

                    std::cout << "Triangle defined. Outline and fill calculated." << std::endl;
                    std::cout << "Press 'C' to clear and select new points." << std::endl;
                }
            } else {
                 std::cout << "All 3 endpoints already selected. Press 'C' to clear." << std::endl;
            }
            glutPostRedisplay();
        } else {
             std::cout << "Clicked outside grid bounds (" << -gridDimension << " to " << gridDimension << ")." << std::endl;
        }
    }
}

// --- Keyboard Callback ---
void keyboard(unsigned char key, int x, int y) {
    switch (key) {
        case 'c': // Clear all selections
        case 'C':
        case 'r': // Reset - make same as clear for simplicity
        case 'R':
            clearAll();
            std::cout << "Cleared all points and fill. Select 3 new endpoints." << std::endl;
            break;
        case 27: // Escape key
             exit(0);
            break;
    }
    glutPostRedisplay();
}

// --- Clear All Helper ---
void clearAll() {
    currentEndpoint = 0;
    endpointsSelected = false;
    lines.clear();
    triangleFillPixels.clear();
    // No need to reset endpoint coordinates, they will be overwritten
}

// --- Menu Creation ---
void createMenu() {
    int menu = glutCreateMenu(menuCallback);
    glutAddMenuEntry("Grid Range: 10x10 (-10 to 10)", 10);
    glutAddMenuEntry("Grid Range: 15x15 (-15 to 15)", 15);
    glutAddMenuEntry("Grid Range: 20x20 (-20 to 20)", 20);
    glutAttachMenu(GLUT_RIGHT_BUTTON);
}

// --- Menu Callback ---
void menuCallback(int option) {
    if (gridDimension != option) {
        gridDimension = option;
        std::cout << "Grid selection range set to: " << gridDimension << "x" << gridDimension
                  << " (" << -gridDimension << " to " << gridDimension << ")" << std::endl;
        clearAll(); // Clear everything if grid range changes
        glutPostRedisplay();
    }
}

// --- Faint Grid Drawing --- (For selection aid)
void drawFaintGrid() {
    int centerX = windowWidth / 2;
    int centerY = windowHeight / 2;

    // Calculate pixel boundaries based on centered grid
    // Use window coords directly now due to gluOrtho2D
    int minPixelX = centerX - (gridDimension * cellSize) - (cellSize / 2);
    int maxPixelX = centerX + (gridDimension * cellSize) + (cellSize / 2);
    int minPixelY = centerY - (gridDimension * cellSize) - (cellSize / 2);
    int maxPixelY = centerY + (gridDimension * cellSize) + (cellSize / 2);


    glColor3f(0.15f, 0.15f, 0.15f); // Very faint gray for lines

    // Draw vertical grid lines
    for (int i = -gridDimension; i <= gridDimension + 1; i++) {
        int x = centerX + i * cellSize - cellSize / 2;
        glBegin(GL_LINES);
        glVertex2i(x, minPixelY);
        glVertex2i(x, maxPixelY);
        glEnd();
    }

    // Draw horizontal grid lines
    for (int i = -gridDimension; i <= gridDimension + 1; i++) {
        int y = centerY + i * cellSize - cellSize / 2; // Use '+' for Y due to gluOrtho2D
        glBegin(GL_LINES);
        glVertex2i(minPixelX, y);
        glVertex2i(maxPixelX, y);
        glEnd();
    }

    // Optional: Draw faint axes or origin marker
    int originCellX = centerX - cellSize / 2;
    int originCellY = centerY - cellSize / 2;
    glColor3f(0.3f, 0.3f, 0.3f); // Slightly less faint for origin/axes
    // Draw cross at origin cell
    glBegin(GL_LINES);
    glVertex2i(originCellX, originCellY + cellSize / 2);
    glVertex2i(originCellX + cellSize, originCellY + cellSize / 2);
    glVertex2i(originCellX + cellSize / 2, originCellY);
    glVertex2i(originCellX + cellSize / 2, originCellY + cellSize);
    glEnd();
}


// --- Simple Filled Cell Drawing ---
void drawFilledCell(int x, int y, float r, float g, float b) {
    int centerX = windowWidth / 2;
    int centerY = windowHeight / 2;
    // Calculate bottom-left corner pixel coordinates for the cell
    int cellX = centerX + x * cellSize - cellSize / 2;
    int cellY = centerY + y * cellSize - cellSize / 2; // Use '+' for Y due to gluOrtho2D

    glColor3f(r, g, b);
    glBegin(GL_QUADS);
    glVertex2i(cellX, cellY);                // Bottom-left
    glVertex2i(cellX + cellSize, cellY);     // Bottom-right
    glVertex2i(cellX + cellSize, cellY + cellSize); // Top-right
    glVertex2i(cellX, cellY + cellSize);     // Top-left
    glEnd();
}

// --- Outline Cell Drawing ---
// Draws a single cell for the outline with specific colors based on Midpoint move
void drawCell(int x, int y, bool isE, bool isNE) {
    float r, g, b;
    if (isE) {
        r = 0.0f; g = 1.0f; b = 0.0f; // Green for E - Requirement 4
    } else if (isNE) {
        r = 0.0f; g = 0.0f; b = 1.0f; // Blue for NE - Requirement 4
    } else {
        r = 1.0f; g = 1.0f; b = 1.0f; // White for starting pixel
    }
    // Use the helper function to draw the cell with the determined color
    drawFilledCell(x, y, r, g, b);
}


// --- Coordinate Conversion ---
// Converts window pixel coordinates (x, y - origin bottom-left) to grid coordinates
void convertScreenToGrid(int screenX, int screenY, int& gridX, int& gridY) {
    int centerX = windowWidth / 2;
    int centerY = windowHeight / 2;

    // Calculate distance from center in pixels
    float pixelDx = (float)(screenX - centerX);
    float pixelDy = (float)(screenY - centerY);

    // Convert pixel distance to grid coordinates (divide by cell size)
    // Round to nearest integer grid coordinate
    gridX = static_cast<int>(std::floor(pixelDx / cellSize + 0.5f));
    gridY = static_cast<int>(std::floor(pixelDy / cellSize + 0.5f));
}

// --- Draw Lines --- (Outline)
// Calls drawCell for each pixel calculated by Midpoint algorithm
void drawLines() {
    for (const auto& line : lines) {
        if (!line.pixels.empty()) {
            // Draw each pixel using its stored E/NE flags to determine color
            for (const auto& pixel : line.pixels) {
                 drawCell(pixel.x, pixel.y, pixel.isE, pixel.isNE);
            }
        }
    }
}

// --- Midpoint Line Algorithm --- (For Outline)
// Calculates pixels for a line segment and stores them in the Line object
void drawMidpointLine(Line& currentLine) { // Pass by reference to modify pixels vector
    currentLine.pixels.clear(); // Ensure pixels are clear before calculating

    int x0 = currentLine.start.x;
    int y0 = currentLine.start.y;
    int x1 = currentLine.end.x;
    int y1 = currentLine.end.y;

    // Use flags for transformation to handle all octants
    bool steep = abs(y1 - y0) > abs(x1 - x0);
    bool swapXY = steep;

    if (steep) {
        std::swap(x0, y0);
        std::swap(x1, y1);
    }

    if (x0 > x1) {
        std::swap(x0, x1);
        std::swap(y0, y1);
         // Also swap start/end in the original line struct if needed? No, Midpoint logic handles direction.
    }

    int dx = x1 - x0;
    int dy = abs(y1 - y0);
    int signY = (y0 < y1) ? 1 : -1; // Direction of Y increment

    int d = 2 * dy - dx;       // Initial decision parameter
    int delE = 2 * dy;         // Increment if E is chosen
    int delNE = 2 * (dy - dx); // Increment if NE is chosen

    int x = x0; // Start at the (potentially transformed) left point
    int y = y0;

    // Lambda to add pixels, reversing transformation
    auto addPixel = [&](int plot_x, int plot_y, bool isE, bool isNE) {
        int original_x = swapXY ? plot_y : plot_x;
        int original_y = swapXY ? plot_x : plot_y;
        // The start pixel is marked isE=false, isNE=false
        currentLine.pixels.push_back({original_x, original_y, isE, isNE});
    };

    // Add the first point
    addPixel(x, y, false, false);

    // Loop through x from first point to last in the transformed coordinate system
    while (x < x1) {
        bool movedE = false;
        bool movedNE = false;
        if (d <= 0) { // Choose E (East)
            d += delE;
            x++;
            // y remains the same
            movedE = true;
        } else { // Choose NE (Northeast)
            d += delNE;
            x++;
            y += signY; // Increment y in the correct direction
            movedNE = true;
        }
        // Add the new point with flags indicating the move made
        addPixel(x, y, movedE, movedNE);
    }
}

// --- Triangle Fill --- (Using Bounding Box + Half-Plane Check)
void fillTriangle(const Cell& v1, const Cell& v2, const Cell& v3) {
    triangleFillPixels.clear();

    // 1. Find bounding box of the triangle in grid coordinates
    int minX = std::min({v1.x, v2.x, v3.x});
    int maxX = std::max({v1.x, v2.x, v3.x});
    int minY = std::min({v1.y, v2.y, v3.y});
    int maxY = std::max({v1.y, v2.y, v3.y});

    // Optional: Clamp bounding box to overall grid dimensions if necessary
    minX = std::max(minX, -gridDimension);
    maxX = std::min(maxX, gridDimension);
    minY = std::max(minY, -gridDimension);
    maxY = std::min(maxY, gridDimension);

    // 2. Determine a consistent orientation (e.g., sign for CCW)
    // Calculate sign for one edge relative to the third vertex.
    float orientation_sign = cross_product_sign(v1, v2, v3);

    // If orientation_sign is 0, the points are collinear, no area to fill.
    if (orientation_sign == 0.0f) {
        std::cout << "Vertices are collinear, no triangle area to fill." << std::endl;
        return; // No fill for degenerate triangle
    }

    // 3. Iterate through each grid cell within the bounding box
    for (int y = minY; y <= maxY; ++y) {
        for (int x = minX; x <= maxX; ++x) {
            Cell p = {x, y, false, false}; // Current grid cell center (using integer coords)

            // Calculate the cross product sign for the point 'p' relative to each edge
            // Ensure edges are checked in a consistent order (e.g., v1->v2, v2->v3, v3->v1)
            float d12 = cross_product_sign(v1, v2, p);
            float d23 = cross_product_sign(v2, v3, p);
            float d31 = cross_product_sign(v3, v1, p);

            // Check if the point 'p' is on the same side of all edges (or on the edge).
            // The check depends on the triangle's orientation (CW or CCW).
            // If orientation_sign > 0 (CCW), then d12, d23, d31 should all be >= 0.
            // If orientation_sign < 0 (CW), then d12, d23, d31 should all be <= 0.

            bool inside = false;
            if (orientation_sign > 0) { // Assuming CCW
                if (d12 >= 0 && d23 >= 0 && d31 >= 0) {
                    inside = true;
                }
            } else { // Assuming CW
                if (d12 <= 0 && d23 <= 0 && d31 <= 0) {
                    inside = true;
                }
            }


            if (inside) {
                // Add cell to fill list (don't need isE/isNE for fill)
                 triangleFillPixels.push_back({x, y, false, false});
            }
        }
    }
    std::cout << "Fill calculation complete. Added " << triangleFillPixels.size() << " pixels." << std::endl;
}